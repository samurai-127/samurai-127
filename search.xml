<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>快速复习git</title>
    <url>/2024/06/26/git%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="1-博客前言"><a href="#1-博客前言" class="headerlink" title="1. 博客前言"></a>1. 博客前言</h3><p>这篇博客适用于有git基础的人看，如果没学习过git不建议看这篇博客。<br>本篇博客记录git常用的命令，用于快速复习。基于命令行，对一个项目进行版本控制（不使用图形化界面，例如idea、vscode等）。</p>
<h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><h4 id="2-1-删除git仓库"><a href="#2-1-删除git仓库" class="headerlink" title="2.1 删除git仓库"></a>2.1 删除git仓库</h4><p>​	如果项目是拉取的，或者想要换一个gitee仓库，那么在使用自己的仓库之前需要将之前的删掉。步骤如下：</p>
<ol>
<li><p>打开命令行工具,得航到你的项目所在的目录。</p>
</li>
<li><p>输入以下命令来取消当前项目与Gitee的关联: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<p>这里的”origin”通常是默认的远程仓库名称，但如果你使用了不同的名称，你需要将其替换为实际的远程仓库名。</p>
</li>
<li><p>输入以下命令来检查是否已成功取消关联:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -V</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​		如果没有版本提示，说明就是删除成功了，跳到2.2步</p>
<h4 id="2-2-提交代码到gitee仓库"><a href="#2-2-提交代码到gitee仓库" class="headerlink" title="2.2 提交代码到gitee仓库"></a>2.2 提交代码到gitee仓库</h4><ol>
<li><p>项目初始化。右键自己的项目，或者进项目的目录一级，右键打开git bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 右键自己的项目，或者进项目的目录一级，右键打开git bash</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>



<p>此时文件夹中多出一个.git文件（需要打开隐藏文件夹开关）</p>
<img src="init%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">




</li>
<li><p>添加远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># origin 后面的是自己在gitee上创建的仓库地址</span></span><br><span class="line">git remote add origin https://gitee.com/samurai127/XXX.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否连接成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>提示版本号说明成功绑定</p>
</li>
</ol>
<h4 id="2-3-提交"><a href="#2-3-提交" class="headerlink" title="2.3 提交"></a>2.3 提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将代码提交到本地仓库</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit -m <span class="string">&#x27;版本备注&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码推送到远程仓库。如果多人开发，需要把master换成自己的分支，例如dev01</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>至此，在gitee上已经能够看到提交的代码了</p>
<h4 id="2-4-版本回退"><a href="#2-4-版本回退" class="headerlink" title="2.4 版本回退"></a>2.4 版本回退</h4><p>如果本地的代码被你改的bug一大堆，那么可以尝试恢复到之前交的git仓库的版本。<br>此处推荐使用reset命令进行版本回退（如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法）。</p>
<h5 id="2-4-1-回退到上一个版本"><a href="#2-4-1-回退到上一个版本" class="headerlink" title="2.4.1 回退到上一个版本"></a>2.4.1 回退到上一个版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取所有更新，不同步</span></span><br><span class="line">git fetch --all </span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地代码同步线上最新版本(会覆盖本地所有与远程仓库.上同名的文件);</span></span><br><span class="line">git reset --hard origin/ master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再更新一次 (其实也可以不用，第二二步命令做过了其实)</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h5 id="2-4-2-回退到指定版本"><a href="#2-4-2-回退到指定版本" class="headerlink" title="2.4.2 回退到指定版本"></a>2.4.2 回退到指定版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">git logs</span><br><span class="line"><span class="comment"># 回退版本：f42aa0e换成需要的版本号</span></span><br><span class="line">git reset --hard f42aa0e</span><br></pre></td></tr></table></figure>



<h3 id="3-管理分支开发"><a href="#3-管理分支开发" class="headerlink" title="3. 管理分支开发"></a>3. 管理分支开发</h3><h4 id="3-1-从其他分支更新本地代码"><a href="#3-1-从其他分支更新本地代码" class="headerlink" title="3.1 从其他分支更新本地代码"></a>3.1 从其他分支更新本地代码</h4><p>假设多人开发，我在dev01，另一个成员在dev02，dev02更新后上传到origin dev02，我需要在本地更新dev02的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin dev02:dev01</span><br></pre></td></tr></table></figure>



<p>看一张图了解原理：</p>
<img src="pull%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">

<p><strong>所以：git pull &#x3D; git fetch + git merge</strong></p>
<h4 id="3-2-绑定远程分支和本地分支"><a href="#3-2-绑定远程分支和本地分支" class="headerlink" title="3.2 绑定远程分支和本地分支"></a>3.2 绑定远程分支和本地分支</h4><p>按照3.1的场景，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev02 origin/dev02 </span><br></pre></td></tr></table></figure>

<p>这个命令做了如下事情：</p>
<ol>
<li><strong>创建本地分支</strong>：如果本地不存在名为 dev02 的分支，这个命令会创建一个新的本地分支 dev02。</li>
<li><strong>设置上游分支</strong>：新创建的本地 dev02 分支会自动设置为跟踪（tracking）远程仓库 origin 上的 dev02 分支。这意味着当你以后在这个本地分支上执行 git pull 或 git  push（不带参数）时，Git 会知道要与远程的 origin&#x2F;dev02 分支进行交互。</li>
</ol>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统：（一）快速学习存储器</title>
    <url>/2024/07/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、CPU"><a href="#一、CPU" class="headerlink" title="一、CPU"></a>一、CPU</h2><h3 id="1、冯诺依曼模型"><a href="#1、冯诺依曼模型" class="headerlink" title="1、冯诺依曼模型"></a>1、冯诺依曼模型</h3><p>在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储。</p>
<p>最重要的是定义计算机基本结构为 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong>，这 5 个部分也被称为<strong>冯诺依曼模型</strong>。</p>
<p><img src="Von_Neumann_architecture.svg"></p>
<p><strong>运算器、控制器是在中央处理器（CPU）里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，</strong>比如键盘就是输入设备，显示器就是输出设备。</p>
<p>存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：</p>
<p><img src="%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.webp"></p>
<hr>
<h4 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h4><h4 id="1-什么是内存？"><a href="#1-什么是内存？" class="headerlink" title="1.什么是内存？"></a>1.什么是内存？</h4><p><strong>内存是硬件，是用于存放数据的硬件。</strong></p>
<p>程序执行前需要先放到内存中才能被CPU处理。</p>
<p>内存是与CPU沟通的桥梁，计算机中所有程序的运行都要依靠内存，内存对计算机的影响非常大。</p>
<p><strong>主存储器，内存，内存条，内部存储器是一个东西</strong>。这很重要，不然看到后面概念都混淆。</p>
<h4 id="2-内存的作用"><a href="#2-内存的作用" class="headerlink" title="2.内存的作用"></a>2.内存的作用</h4><p><strong>内存，用于存放CPU中的运算数据以及硬盘等外部存储设备交换的数据。</strong></p>
<p>CPU一般会把需要运算的数据调到主存中进行运算，运算完后CPU将结果再传出来。</p>
<p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p>
<p>在计算机数据存储中，存储数据的基本单位是<strong>字节（byte）</strong>，1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。</p>
<p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p>
<hr>
<h4 id="1-2-中央处理器（CPU）"><a href="#1-2-中央处理器（CPU）" class="headerlink" title="1.2 中央处理器（CPU）"></a>1.2 中央处理器（CPU）</h4><p>中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：</p>
<ul>
<li>32 位 CPU 一次可以计算 4 个字节；</li>
<li>64 位 CPU 一次可以计算 8 个字节；</li>
</ul>
<p>这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。</p>
<p>之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 <code>0~255</code> 范围内的数值，这样就无法一次完成计算 <code>10000 * 500</code> ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 <code>4294967295</code>。</p>
<p>CPU 内部还有一些组件，常见的有<strong>寄存器、控制单元和逻辑运算单元</strong>等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p>
<p><strong>寄存器是计算机中央处理器（CPU）内部的一种高速存储单元，用于临时存储数据和指令。</strong></p>
<p><strong>为什么有了内存还需要寄存器？</strong></p>
<p>因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。</p>
<hr>
<h4 id="1-3-输入、输出设备"><a href="#1-3-输入、输出设备" class="headerlink" title="1.3 输入、输出设备"></a>1.3 输入、输出设备</h4><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p>
<hr>
<h3 id="2、线路位宽与-CPU-位宽（操作系统32位和64位）"><a href="#2、线路位宽与-CPU-位宽（操作系统32位和64位）" class="headerlink" title="2、线路位宽与 CPU 位宽（操作系统32位和64位）"></a>2、线路位宽与 CPU 位宽（操作系统32位和64位）</h3><p>数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。</p>
<p>如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p>
<p>这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。</p>
<p>为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p>
<p>CPU 想要操作「内存地址」就需要「地址总线」：</p>
<ul>
<li>如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；</li>
<li>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。</li>
</ul>
<p>那么，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 <code>2 ^ 32 = 4G</code>。</p>
<p>知道了线路位宽的意义后，我们再来看看 CPU 位宽。</p>
<p>CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。</p>
<p>如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。</p>
<p>对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。</p>
<p>但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以<strong>如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来</strong>。</p>
<p>另外，32 位 CPU 最大只能操作 4GB 内存，就算装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 <code>2^64</code>（256T）</p>
<h2 id="二、存储器的层次结构"><a href="#二、存储器的层次结构" class="headerlink" title="二、存储器的层次结构"></a>二、存储器的层次结构</h2><h3 id="层次结构介绍"><a href="#层次结构介绍" class="headerlink" title="层次结构介绍"></a>层次结构介绍</h3><p>计算机的两类存储器，一是外部存储器，二是内部存储器。<strong>常见的外部存储器主要是磁盘，磁盘又分为硬盘和软盘，而内部存储器就是常说的内存。</strong></p>
<p><strong>小林coding层次结构：</strong></p>
<img src="%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" style="zoom: 80%;">

<p><strong>OS教材：</strong></p>
<img src="OS%E7%9A%84%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1.png" style="zoom: 80%;">

<h3 id="聚焦CPU内部："><a href="#聚焦CPU内部：" class="headerlink" title="聚焦CPU内部："></a>聚焦CPU内部：</h3><p>我们想象中一个场景，大学期末准备考试了，你前去图书馆临时抱佛脚。那么，在看书的时候，我们的大脑会思考问题，也会记忆知识点，另外我们通常也会把常用的书放在自己的桌子上，当我们要找一本不常用的书，则会去图书馆的书架找。</p>
<p>我们可以把 CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的<strong>寄存器</strong>，处理速度是最快的，但是能存储的数据也是最少的，毕竟我们也不能一下同时思考太多的事情，除非你练过。</p>
<p>我们大脑中的记忆，就好比 <strong>CPU Cache</strong>，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</p>
<p>CPU Cache 通常会分为 <strong>L1、L2、L3 三层</strong>，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。我们大脑中短期记忆，就好比 L1 Cache，而长期记忆就好比 L2&#x2F;L3 Cache。</p>
<p>寄存器和 CPU Cache 都是在 CPU 内部，跟 CPU 挨着很近，因此它们的读写速度都相当的快，但是能存储的数据很少，毕竟 CPU 就这么丁点大。</p>
<p><img src="%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.webp"></p>
<h3 id="聚焦CPU外部："><a href="#聚焦CPU外部：" class="headerlink" title="聚焦CPU外部："></a>聚焦CPU外部：</h3><p>知道 CPU 内部的存储器的层次分布，我们放眼看看 CPU 外部的存储器。</p>
<p>当我们大脑记忆中没有资料的时候，可以从书桌或书架上拿书来阅读，那我们桌子上的书，就好比<strong>内存</strong>，我们虽然可以一伸手就可以拿到，但读写速度肯定远慢于寄存器，那图书馆书架上的书，就好比<strong>硬盘</strong>，能存储的数据非常大，但是读写速度相比内存差好几个数量级，更别说跟寄存器的差距了。</p>
<p>硬盘有如下的内容：</p>
<p><strong>机械硬盘（HDD）</strong><br>机械硬盘是计算机中的一种数据存储设备，它使用旋转的盘片和移动的磁头来读写数据。机械硬盘通常比固态硬盘容量更大，价格更便宜，但是速度相对较慢，且比较容易受到机械损伤的影响。机械硬盘通常用于存储大量数据和长期存储。</p>
<p><strong>固态硬盘（SSD）</strong><br>固态硬盘是一种新型的数据存储设备，它使用闪存芯片来读写数据。固态硬盘比机械硬盘速度更快，能够更快地启动计算机和打开文件，且比较抗震抗摔，寿命也更长。但是，固态硬盘价格相对较高，容量相对较小。</p>
<p>在第一节介绍内存的时候，曾说内存就是主存，<strong>但是严格的说，内存包括主存(内存条,基于DRAM)与高速缓存(Cache,基于SRAM)两部分。</strong></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-CPU的寄存器"><a href="#1-CPU的寄存器" class="headerlink" title="1. CPU的寄存器"></a>1. CPU的寄存器</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>寄存器是CPU内部的高速存储单元，用于暂时存储CPU运算过程中的数据和指令。</p>
</li>
<li><p>它们具有极快的访问速度，能够减少CPU对内存的访问次数，提高程序执行效率。</p>
</li>
</ol>
<h4 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>内存（RAM，随机存取存储器）是计算机系统中用于存储数据和程序的临时存储器。</p>
</li>
<li><p>提供了较大的存储容量，但相对于CPU的访问速度较慢。</p>
</li>
</ol>
<p><strong>与CPU的关系</strong></p>
<ol>
<li><p>CPU通过内存总线与内存进行通信，以读取和写入数据。</p>
</li>
<li><p>当CPU需要执行程序时，它会从内存中读取指令和数据到寄存器中进行处理。</p>
</li>
</ol>
<h4 id="3-高速缓存（Cache）"><a href="#3-高速缓存（Cache）" class="headerlink" title="3. 高速缓存（Cache）"></a>3. 高速缓存（Cache）</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>高速缓存是位于CPU和内存之间的一种存储器层次结构，用于存储CPU频繁访问的数据和指令。</p>
</li>
<li><p>它通过减少CPU对内存的访问次数来提高计算机系统的性能。</p>
</li>
</ol>
<p><strong>多级缓存结构</strong></p>
<ol>
<li><p>通常包括L1、L2、L3等多级缓存，其中L1缓存距离CPU最近且速度最快，L2、L3缓存则更大但速度稍慢。</p>
</li>
<li><p>这种多级缓存结构旨在利用容量、速度和成本之间的平衡，以提供更好的性能。</p>
</li>
</ol>
<h4 id="4-寄存器、内存与高速缓存之间的联系"><a href="#4-寄存器、内存与高速缓存之间的联系" class="headerlink" title="4. 寄存器、内存与高速缓存之间的联系"></a>4. 寄存器、内存与高速缓存之间的联系</h4><p><strong>数据传输</strong></p>
<ol>
<li><p>当CPU执行程序时，它会从内存中读取指令和数据到寄存器中进行处理。</p>
</li>
<li><p>如果这些指令和数据已经存储在高速缓存中，则CPU可以直接从缓存中读取，减少了对内存的访问次数。</p>
</li>
</ol>
<p><strong>性能提升</strong></p>
<ol>
<li><p>寄存器和高速缓存的存在大大提高了CPU的数据访问速度，从而提升了计算机系统的整体性能。</p>
</li>
<li><p>它们通过减少CPU对内存的依赖，降低了内存访问的延迟和能耗。</p>
</li>
</ol>
<p><strong>协同工作</strong></p>
<ol>
<li><p>寄存器、内存和高速缓存之间通过复杂的协同工作机制，共同支持CPU的高效运行。</p>
</li>
<li><p>寄存器提供快速的数据访问能力，高速缓存减少了对内存的访问次数，而内存则提供了较大的存储容量以支持复杂的程序和数据结构。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库：（一）索引底层原理与实现</title>
    <url>/2024/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="一、-什么是索引？"><a href="#一、-什么是索引？" class="headerlink" title="一、 什么是索引？"></a>一、 什么是索引？</h2><p>索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，可以大大加快查询的速度，使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。索引的作用类似于书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<h3 id="1-1-索引概述（了解）"><a href="#1-1-索引概述（了解）" class="headerlink" title="1.1 索引概述（了解）"></a>1.1 索引概述（了解）</h3><p>当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当作一个整体来访问的，这样可以保证操作的原子性。硬盘数据块存储结构类似于链表，都包含数据部分，以及一个指向下一个节点（或数据块）的指针，不需要连续存储。</p>
<p>记录集只能在某个关键字段上进行排序，所以如果需要在一个无序字段上进行搜索，就要执行一个线性搜索（Linear Search）的过程，平均需要访问 N&#x2F;2 的数据块，N 是表示所占据的数据块数目。如果这个字段是一个非主键字段（也就是说，不包含唯一的访问入口）， 那么需要在 N 个数据块上搜索整个表格空间。</p>
<p>但是对于一个有序字段，可以运用二分查找（BinarySearch），这样只需要访问 log2(N)的数据块。这就是为什么数据表使用索引后性能可以得到本质上提高的原因。</p>
<p>索引是对记录集的多个字段进行排序的方法。在一张表中为一个字段创建一个索引，将创建另外一个数据结构，包含字段数值以及指向相关记录的指针，然后对这个索引结构进行排序，允许在该数据上进行二分法排序。索引需要额外的磁盘空间。</p>
<p>对于 MyISAM 引擎而言，这些索引是被统一保存在一张表中的。如果很多字段都建立了索引，那么会占用大量的磁盘空间，这个文件将很快到达底层文件系统所能够支持的大小限制。</p>
<h4 id="1-1-1-索引的作用"><a href="#1-1-1-索引的作用" class="headerlink" title="1.1.1 索引的作用"></a>1.1.1 索引的作用</h4><p>索引除了快没有其他的作用，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。</p>
<h4 id="1-1-2-索引的查找过程"><a href="#1-1-2-索引的查找过程" class="headerlink" title="1.1.2 索引的查找过程"></a>1.1.2 索引的查找过程</h4><p>举一个例子，三个表t1、t2、t3，每个表中只有一个字段，但是每一个表中都有1000行记录，这些记录都是1~1000的数字。</p>
<p>执行以下的查找语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3;</span><br></pre></td></tr></table></figure>


<p>在无索引的情况下处理此查询， 必须寻找 3 个表所有的组合，以便得出与 WHERE 子句相配的那些行。而可能的组合数目 为 1000×1000×1000（十亿）</p>
<p>如果对每个表进行索引，就能极大地加速查询进程，利用索引的查询处理如下。</p>
<p>从表 t1 中选择第一行，查看此行所包含的数据。<br>使用表 t2 上的索引，直接定位 t2 中与 t1 的值匹配的行。同理，利用表 t3 上的索引， 直接定位 t3 中与 t1 的值匹配的行。<br>扫描表 t1 的下一行并重复前面的过程，直到遍历 t1 中所有的行。<br>在这样的情况下，对表 t1 执行了一个完全扫描，但能够在表 t2 和 t3 上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。<br>利用索引，MySQL 加速了 WHERE 子句满足条件行的搜索，而在多表连接查询时、在执行连接时加快了与其他表中的行匹配的速度。</p>
<h2 id="二、索引的分类（逻辑分类）"><a href="#二、索引的分类（逻辑分类）" class="headerlink" title="二、索引的分类（逻辑分类）"></a>二、索引的分类（逻辑分类）</h2><p>逻辑的角度来划分，索引分为普通索引、唯一索引、主键索引、组合索引和全文索引。</p>
<h3 id="2-1-普通索引"><a href="#2-1-普通索引" class="headerlink" title="2.1 普通索引"></a>2.1 普通索引</h3><h4 id="2-1-1-普通索引格式"><a href="#2-1-1-普通索引格式" class="headerlink" title="2.1.1 普通索引格式"></a>2.1.1 普通索引格式</h4><p>普通索引是最基本的索引，它没有任何限制，也是大多数情况下用到的索引。</p>
<p>直接创建索引的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># column 是指定要创建索引的列名</span></span><br><span class="line"><span class="comment"># length 是可选项</span></span><br><span class="line">mysql&gt;CREATE INDEX index_name ON table_name (column(length));</span><br></pre></td></tr></table></figure>

<p>索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字 节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。</p>
<h4 id="2-1-2-创建普通索引"><a href="#2-1-2-创建普通索引" class="headerlink" title="2.1.2 创建普通索引"></a>2.1.2 创建普通索引</h4><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);  <span class="comment">##创建一个表结构</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   |     | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create index id_index on info(<span class="built_in">id</span>);    <span class="comment">##为info表中的id创建索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到在key下面的MUL，索引创建成功了</span></span><br></pre></td></tr></table></figure>




<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">修改表结构的方式添加索引</span><br><span class="line">mysql&gt;ALTER TABLE table_name ADD INDEX index_name (column(length));</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info add index name_index (name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>方法三：<br>在创建一个表结构时，就创建索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table num (<span class="built_in">id</span> int(3),index id_index(<span class="built_in">id</span>));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; describe num;</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| Field | Type   | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>    | int(3) | YES  | MUL | NULL    |       |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<h4 id="2-1-3-查看索引"><a href="#2-1-3-查看索引" class="headerlink" title="2.1.3 查看索引"></a>2.1.3 查看索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from info\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: id_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: name_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h3 id="2-2-唯一索引"><a href="#2-2-唯一索引" class="headerlink" title="2.2 唯一索引"></a>2.2 唯一索引</h3><p>唯一索引与普通索引类似，不同的就是：唯一索引的索引列的值必须唯一，但允许有空<br>值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一。唯一索引创建方法和普<br>通索引类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改表结构的时候添加唯一索引：</span></span><br><span class="line">mysql&gt;CREATEUNIQUEINDEXindex_nameON table_name(column(length));</span><br></pre></td></tr></table></figure>

<p>新建一个表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create unique index unique_name on info2(name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>修改表结构的时候添加唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式</span><br><span class="line">mysql&gt;ALTERTABLEtable_nameADD UNIQUEindex_name(column(length));</span><br></pre></td></tr></table></figure>


<p>创建表的时候同时创建唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATETABLE`table`( </span><br><span class="line">...</span><br><span class="line">UNIQUE index Name (title(length)) );</span><br></pre></td></tr></table></figure>

<h3 id="2-3-主键索引"><a href="#2-3-主键索引" class="headerlink" title="2.3 主键索引"></a>2.3 主键索引</h3><p>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</p>
<p>主键索引也就是primary key，在之前的创建表的过程中已经演示过，有两种方式。</p>
<p>第一种：在字段外创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br></pre></td></tr></table></figure>

<p>第二种：在字段内创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null primary key,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-组合索引（最左前缀）"><a href="#2-4-组合索引（最左前缀）" class="headerlink" title="2.4 组合索引（最左前缀）"></a>2.4 组合索引（最左前缀）</h3><p>平时用的 SQL 查询语句一般都有比较多的限制条件，所以为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。在组合索引的创建中，有两种场景，即为单列索引和多列索引。</p>
<p>特点：<br>遵从最左原则，从左往右依次执行；</p>
<h3 id="2-5-全文索引"><a href="#2-5-全文索引" class="headerlink" title="2.5 全文索引"></a>2.5 全文索引</h3><p>对于较大的数据集，将资料输入一个没有 FULLTEXT 索引的表中，然后创建索引，其 速度比把资料输入现有 FULLTEXT 索引的速度更快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间、非常消耗硬盘空间的做法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info2 add fulltext index addr_index(address);    <span class="comment">##创建全文索引</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  | MUL | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; show index from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>




<h2 id="三、-查看及删除索引"><a href="#三、-查看及删除索引" class="headerlink" title="三、 查看及删除索引"></a>三、 查看及删除索引</h2><h3 id="3-1-查看索引"><a href="#3-1-查看索引" class="headerlink" title="3.1 查看索引"></a>3.1 查看索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看索引的两种方法</span><br><span class="line">mysql&gt;show index from tablename;</span><br><span class="line">mysql&gt;show keys from tablename;</span><br></pre></td></tr></table></figure>


<p>以show keys from tablename为例，两种方法用法相同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show keys from info2;</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| info2 |          0 | PRIMARY     |            1 | <span class="built_in">id</span>          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          0 | unique_name |            1 | name        | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          1 | addr_index  |            1 | address     | NULL      |           0 |     NULL | NULL   | YES  | FULLTEXT   |         |               |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>可以使用 mysql&gt; show keys from info2\G;使用显示结果更加直观</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; mysql&gt; show keys from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Table：表的名称。</p>
</li>
<li><p>Non_unique：如果索引不能包括重复词，则为 0；如果可以，则为 1。</p>
</li>
<li><p>Key_name：索引的名称。</p>
</li>
<li><p>Seq_in_index：索引中的列序号，从 1 开始。</p>
</li>
<li><p>Column_name：列名称。</p>
</li>
<li><p>Collation：列以什么方式存储在索引中。在 MySQL 中，有值‘A’（升序）或 NULL（无分类）。</p>
</li>
<li><p>Cardinality：索引中唯一值数目的估计值。通过运行 ANALYZETABLE 或 myisamchk-a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没 有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</p>
</li>
<li><p>Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列 被编入索引，则为 NULL。</p>
</li>
<li><p>Packed：指示关键字如何被压缩。如果没有被压缩，则为 NULL。</p>
</li>
<li><p>Null：如果列含有 NULL，则含有 YES。如果没有，则该列含有 NO。</p>
</li>
<li><p>Index_type：用过的索引方法（BTREE, FULLTEXT,HASH, RTREE）。</p>
</li>
<li><p>Comment：备注。</p>
</li>
</ol>
<h3 id="3-2-删除索引"><a href="#3-2-删除索引" class="headerlink" title="3.2 删除索引"></a>3.2 删除索引</h3><p>索引在创建之后，是会占用一定的磁盘空间的，因此表内如果有不再使用的索引，从数据库性能方面考虑，最好是删除无用索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">删除索引的两种方式</span><br><span class="line">DROP INDEX 索引名 ON 表名; </span><br><span class="line">ALTER TABLE 表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop index addr_index on info2;    <span class="comment">##删除刚刚创建的全文索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show keys from info2\G;   </span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h2 id="四、-索引的底层原理"><a href="#四、-索引的底层原理" class="headerlink" title="四、 索引的底层原理"></a>四、 索引的底层原理</h2><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>Mysql数据库中的常见索引结构有多种，常用Hash，B+树（最常用，多路搜索树）等数据结构来进行数据存储。树的深度加深一层，意味着多一次查询，对于数据库磁盘而言，就是多一次IO操作，导致查询效率低下。</p>
<p><strong>创建一次索引就代表了创建了一个数据结构，例如B+树。</strong></p>
<p><strong>B+树的特征：</strong></p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li>
<li>更适合文件索引系统；</li>
</ol>
<p>此处讨论B+树，结合案例见4.3。</p>
<h3 id="4-2-搜索引擎"><a href="#4-2-搜索引擎" class="headerlink" title="4.2 搜索引擎"></a>4.2 搜索引擎</h3><p>常见的有InnoDB、MyASIM（不支持数据库事务）、Memory等。存储引擎和存储方式（磁盘等）见文章：<a href="https://blog.csdn.net/wangfeijiu/article/details/112454405">MySQL体系构架、存储引擎和索引结构</a></p>
<p>此处使用InnoDB来讨论索引的存储结构，见4.3。</p>
<h3 id="4-3-InnoDB-B-树存储数据结构"><a href="#4-3-InnoDB-B-树存储数据结构" class="headerlink" title="4.3 InnoDB B+树存储数据结构"></a>4.3 InnoDB B+树存储数据结构</h3><p>存储数据结构，也是索引分类的一种：物理分类（第二章讲了逻辑分类）。物理分类分为<strong>聚簇索引</strong>和非聚簇索引。存储数据结构虽然说是索引分类的一种，但是准确的来说，<strong>聚簇索引和非聚簇索引是一种数据的存储方式。</strong></p>
<p><strong>聚簇索引（clustered index）</strong>不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<img src="%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p><strong>非聚簇索引（辅助索引或者二级索引）</strong>：数据和索引是分开的，非聚簇索引的叶子节点并不存储数据表中的完整数据记录。相反，它们存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。</p>
<img src="%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p>虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是只有InnoDB的<strong>主键索引</strong>（主键索引见2.3）才是聚簇索引，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。</p>
<p><strong>使用聚簇索引的优缺点（面试）：</strong></p>
<p>优点：</p>
<ol>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂（页分裂见4.2链接、下图，属于操作系统的知识），严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）</p>
</li>
<li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
</li>
<li><p>二级索引（非聚簇索引）访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
</li>
</ol>
<img src="f6cd40465df212dd91614785713be6cb.gif" style="zoom:150%;">





<h3 id="4-4-回表是什么？为什么会有回表？"><a href="#4-4-回表是什么？为什么会有回表？" class="headerlink" title="4.4 回表是什么？为什么会有回表？"></a>4.4 回表是什么？为什么会有回表？</h3><p>在4.3的聚簇索引中，我们提到缺点的第三条，非聚簇索引需要两次索引查找，这个过程我们就称为回表。</p>
<p>为什么会有回表？我们刚说到，聚簇索引是将索引和数据存储放在一起的，所以找到索引了就是找到了数据。但是根据实际查询的要求，不一定只会根据主键去查询数据。我们看以下场景：</p>
<p>假如有个表T， 里面三个字段：id k name， id为主键，并且其中对k建立了单独索引。此时有两棵B+树，一个是聚簇索引（主键索引）的B+树，一个是非聚簇索引的B+树。</p>
<ol>
<li><p>如果语句是 select * from T where id&#x3D;500，即主键查询方式（聚簇索引），则只需要搜索 ID 这棵 B+ 树，查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k from T where k&#x3D;5，即普通索引查询方式（非聚簇索引），则只要搜索 k 索引树，这样的话查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k , name from T where k&#x3D;5，第一次通过普通索引查询方式得到 id 的值为 500，再到 id 索引树搜索一次（需要回表才能查到name这个数据）。此时这个过程就成为回表了，回表是基于聚簇索引的缺点之一。</p>
</li>
</ol>
<p>所以为了避免回表，那么可以将k和name建成联合索引（<strong>因为在非主键索引就可以查询到数据，也称为覆盖索引）。</strong></p>
<p><strong>为什么建成联合索引就可以避免回表？</strong></p>
<p>在4.3中提到，非聚簇索引的叶子结点存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。那么查询到K或者name后，自然的指向了对应的id，那么这个行数据自然也就拿到了。</p>
<h2 id="五、总结-面试"><a href="#五、总结-面试" class="headerlink" title="五、总结+面试"></a>五、总结+面试</h2><p>本篇文章介绍了索引的类型，底层原理。mysql的语句了解即可，需要时查起来就可以。另外，文章针对面试需要知道的内容，这样背八股文也能很快反应过来不需要记得太难。</p>
<p>面试需要掌握的知识：mysql的搜索引擎和搜索引擎的差别（4.2节）、mysql的底层存储原理（4.1节，B+树等），mysql数据库优化（4.4节，涉及索引优化），另外需要掌握：mysql锁，mysql事务、mysql数据库优化、数据库备份等。</p>
<h2 id="六、附上一篇美团讲解的索引内容"><a href="#六、附上一篇美团讲解的索引内容" class="headerlink" title="六、附上一篇美团讲解的索引内容"></a>六、附上一篇美团讲解的索引内容</h2><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">美团：MySQL索引原理及慢查询优化</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（一）排序算法</title>
    <url>/2024/07/03/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序必备图示网站"><a href="#排序必备图示网站" class="headerlink" title="排序必备图示网站"></a>排序必备图示网站</h1><p>一个链接看完所有排序算法的图示：<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法图示</a></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>核心思想: </p>
<ol>
<li>相邻的元素两两比较，大的放右边，小的放左边。</li>
<li>第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。</li>
<li>如果数组中有n个数据，总共我们只要执行n- 1轮的代码就可以。</li>
</ol>
<p>重点在于冒泡排序的优化：</p>
<p>第二层for循环中可以-i，进而提高效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoBubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//-1防止索引越界</span></span><br><span class="line">            <span class="comment">///-i提高效率</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序使用双指针法的对撞指针，定义start指针（左指针）和end指针（右指针）查找指针指向的数组元素和baseNumber的关系</p>
<p>在第一轮的排序中，通过方法会确定基准数的位置，接下来按照基准数的位置将会划分以基准数为中间的左右两个区间，再对两个区间进行递归（递归时不断的二分区间）完成排序。</p>
<p>注意点：</p>
<ol>
<li>end指针一定要先动</li>
<li>递归需要定义出口</li>
<li>baseNumber需要在出口后定义否则可能索引越界</li>
<li>递归的地方是quickSort(arr, i, start - 1)和quickSort(arr, start + 1, j);</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doQuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 1、输入数组个数和数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用快速排序</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、打印排序结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//1、确定基准数、左指针、右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归函数的出口</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*baseNumber应该放在判断结束之后*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">baseNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、当end指针在start指针右边，或者是两个指针没有重合时都需要进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (end != start) &#123;</span><br><span class="line">            <span class="comment">// 当end指针指向的数字比baseNumber小的时候，end指针停止</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[end] &lt; baseNumber || end &lt;= start) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当start指针指向的数字比baseNumber大的时候，start指针停止</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[start] &gt; baseNumber || end &lt;= start) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//此时运行到这里，两个指针指向的位置已经确定了，交换两个指针对应的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 退出最外层循环后，start,end指向同一个位置，即baseNumber的位置，基准数归位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一轮排序结束，开始递归</span></span><br><span class="line">        quickSort(arr, i, start - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, start + <span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在baseNumber定义之前设置递归出口</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="1、合并有序数组"><a href="#1、合并有序数组" class="headerlink" title="1、合并有序数组"></a>1、合并有序数组</h2><p>将数组内的两个区间内的有序元素进行合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以将该数组看为{1,5,6}和{2,3,7,8}，合并后仍然用原来的空间存储数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>假设已知两个数组的范围，第一个是l到lEnd，第二个是rEnd到rEnd，那么合并两个的代码如下：</p>
<p>其中l和r变量不仅充当范围的作用，还是一个指针，指向当前元素的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> lEnd, <span class="type">int</span> r, <span class="type">int</span> rEnd, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l;<span class="comment">//temp数组的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd &amp;&amp; r &lt;= rEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                temp[k++] = arr[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd) &#123;</span><br><span class="line">            temp[k++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= rEnd) &#123;</span><br><span class="line">            temp[k++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，我们使用一个中间数组temp去存储变量，k的值去记录temp的索引，比较两个区间的值，小的就放进temp数组就可以了。</p>
<p><strong>下面两个while循环的作用是什么？</strong></p>
<p>如果说第一个区间的l指针已经走到了末尾，那么第二个区间的r指针肯定没有走到结尾。又因为两个区间都是排好序的，所以第二个区间剩下的元素肯定都是比第一个区间的数字要大的，直接拼接到temp数组后面就行了。也就是说，两个while循环还可以换成以下写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &gt; lEnd) &#123;</span><br><span class="line">    System.arraycopy(arr, r, temp, k, rEnd - r + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt; rEnd) &#123;</span><br><span class="line">    System.arraycopy(arr, l, temp, k, lEnd - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、使用合并数组实现归并排序"><a href="#2、使用合并数组实现归并排序" class="headerlink" title="2、使用合并数组实现归并排序"></a>2、使用合并数组实现归并排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoMergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 1、输入数组个数和数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义初始数组的区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用sort方法进行排序</span></span><br><span class="line">        mergeSort(arr, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 3、归并排序讲究分治的思想，对于拿到的一个数组，不断的进行对半拆分，直到每个区间都拆到只剩1个元素后再对两个区间合并</span></span><br><span class="line"><span class="comment">         * 合并的时候进行排序，不断的递归</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 定义临时数组存储数据，如果在split中创建的话每次递归都会创建一个数组，所以写在这里</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        split(arr, left, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、治：当区间中只有一个元素的时候认为数组有序（提供递归的出口）</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、分：不断的将每一个区间进行拆分，直到拆到一个区间只有一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//算平均值</span></span><br><span class="line"></span><br><span class="line">        split(arr, left, mid, temp);<span class="comment">//递归</span></span><br><span class="line">        split(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、合</span></span><br><span class="line">        merge(arr, left, mid, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        System.arraycopy(temp, left, arr, left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> lEnd, <span class="type">int</span> r, <span class="type">int</span> rEnd, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l;<span class="comment">//temp数组的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd &amp;&amp; r &lt;= rEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                temp[k++] = arr[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd) &#123;</span><br><span class="line">            temp[k++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= rEnd) &#123;</span><br><span class="line">            temp[k++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>比较难的地方：</strong></p>
<ol>
<li><p>split方法比较难理解，我用代码输出一下拆分的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split方法</span></span><br><span class="line"><span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入案例</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分过程</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">4</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<p>可以看到流程是这样的（数据不一样）：<img src="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif">只有拆分到最小的时候（就是区间只有一个元素的时候)，递归结束，到merge方法进行合并。而merge中就实现排序的方法逻辑。</p>
</li>
<li><p>在merge方法中，我设置了temp数组的索引k值。之前我写的是k&#x3D;0，而不是k&#x3D;l，这里是不对的。为什么不对？</p>
<p>其实在整个归并的过程中，两个子数组归并到上一级的数组的时候，temp数组是要进行覆盖之前的元素的，而上一级的数组排序的时候，应该为两个子数组的最左边的那个范围。</p>
<p>我们拿split的例子来说，得到两个子数组[9,3]和[7,2]的时候，l的值是0，那么排序的时候k应该从0开始，得到两个子数组[8,5]和[1,4]的时候，i的值应该对应8索引，然后赋值到temp索引中。所以merge方法的k索引取决于扔进去的两个区间的最左边的范围。<img src="temp%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95.png" style="zoom:80%;"></p>
</li>
<li><p>范围上都是left到mid，mid+1到right</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">split(arr, left, mid, temp);<span class="comment">//递归</span></span><br><span class="line">split(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//递归</span></span><br><span class="line">merge(arr, left, mid, mid + <span class="number">1</span>, right, temp);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="面试常考排序算法"><a href="#面试常考排序算法" class="headerlink" title="面试常考排序算法"></a>面试常考排序算法</h1><p><a href="https://blog.csdn.net/qq_45792749/article/details/124410972">面试常考的排序算法</a></p>
<h1 id="acWing代码模板"><a href="#acWing代码模板" class="headerlink" title="acWing代码模板"></a>acWing代码模板</h1><p><a href="https://www.acwing.com/blog/content/31431/">【Java版本】常用代码模板1——基础算法 + 模板题参考实现 - AcWing</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（二）二分查找</title>
    <url>/2024/07/03/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="一、基础二分查找"><a href="#一、基础二分查找" class="headerlink" title="一、基础二分查找"></a>一、基础二分查找</h2><p>直接上代码</p>
<p>左闭右闭区间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt; target</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左闭右开区间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt; target</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>left和right的含义（贼他妈重点，区分两个写法的区间到底怎么写）：</strong></p>
<p>作为<strong>区间</strong>[left,right]或者[left,right)；作为指针指向元素。</p>
<p>在左闭右闭区间中，left&lt;&#x3D;right，right是有可能指向target的，但是left&lt;right，<strong>right只是边界</strong>，right不可能是target。因此在左闭右闭区间的时候，right&#x3D;arr.length-1，而左闭右开区间right&#x3D;arr.length。</p>
<img src="%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E8%8D%89%E7%A8%BF.jpg" style="zoom: 50%;">







<p><strong>二分查找注意点：</strong></p>
<ol>
<li><p><strong>单单只看左闭右闭区间，while循环中到底是left&lt;right还是left&lt;&#x3D;right？</strong></p>
<p>可以有一个具体的例子，当查找的数字是左边界的时候，left&lt;right会漏掉一次查询。因为left和right共同指向一个位置的时候不满足while条件，所以退出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿草稿纸自己写一下，别只看不动笔的</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>&#125;;</span><br><span class="line">target = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>int mid &#x3D; left + ((right - left) &gt;&gt; 1)是什么？为什么不是直接相加除2？</strong></p>
<p>超过int类型的范围以后会变负数。右移运算符&gt;&gt;1相当于转换成二进制除2，需要补一下原码，反码，补码的内容，懒得写了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
