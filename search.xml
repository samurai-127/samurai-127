<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>快速复习git</title>
    <url>/2024/06/26/git%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="1-博客前言"><a href="#1-博客前言" class="headerlink" title="1. 博客前言"></a>1. 博客前言</h3><p>这篇博客适用于有git基础的人看，如果没学习过git不建议看这篇博客。<br>本篇博客记录git常用的命令，用于快速复习。基于命令行，对一个项目进行版本控制（不使用图形化界面，例如idea、vscode等）。</p>
<h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><h4 id="2-1-删除git仓库"><a href="#2-1-删除git仓库" class="headerlink" title="2.1 删除git仓库"></a>2.1 删除git仓库</h4><p>​	如果项目是拉取的，或者想要换一个gitee仓库，那么在使用自己的仓库之前需要将之前的删掉。步骤如下：</p>
<ol>
<li><p>打开命令行工具,得航到你的项目所在的目录。</p>
</li>
<li><p>输入以下命令来取消当前项目与Gitee的关联: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<p>这里的”origin”通常是默认的远程仓库名称，但如果你使用了不同的名称，你需要将其替换为实际的远程仓库名。</p>
</li>
<li><p>输入以下命令来检查是否已成功取消关联:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -V</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​		如果没有版本提示，说明就是删除成功了，跳到2.2步</p>
<h4 id="2-2-提交代码到gitee仓库"><a href="#2-2-提交代码到gitee仓库" class="headerlink" title="2.2 提交代码到gitee仓库"></a>2.2 提交代码到gitee仓库</h4><ol>
<li><p>项目初始化。右键自己的项目，或者进项目的目录一级，右键打开git bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 右键自己的项目，或者进项目的目录一级，右键打开git bash</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>



<p>此时文件夹中多出一个.git文件（需要打开隐藏文件夹开关）</p>
<img src="init%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">




</li>
<li><p>添加远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># origin 后面的是自己在gitee上创建的仓库地址</span></span><br><span class="line">git remote add origin https://gitee.com/samurai127/XXX.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否连接成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>提示版本号说明成功绑定</p>
</li>
</ol>
<h4 id="2-3-提交"><a href="#2-3-提交" class="headerlink" title="2.3 提交"></a>2.3 提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将代码提交到本地仓库</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit -m <span class="string">&#x27;版本备注&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码推送到远程仓库。如果多人开发，需要把master换成自己的分支，例如dev01</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>至此，在gitee上已经能够看到提交的代码了</p>
<h4 id="2-4-版本回退"><a href="#2-4-版本回退" class="headerlink" title="2.4 版本回退"></a>2.4 版本回退</h4><p>如果本地的代码被你改的bug一大堆，那么可以尝试恢复到之前交的git仓库的版本。<br>此处推荐使用reset命令进行版本回退（如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法）。</p>
<h5 id="2-4-1-回退到上一个版本"><a href="#2-4-1-回退到上一个版本" class="headerlink" title="2.4.1 回退到上一个版本"></a>2.4.1 回退到上一个版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取所有更新，不同步</span></span><br><span class="line">git fetch --all </span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地代码同步线上最新版本(会覆盖本地所有与远程仓库.上同名的文件);</span></span><br><span class="line">git reset --hard origin/ master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再更新一次 (其实也可以不用，第二二步命令做过了其实)</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h5 id="2-4-2-回退到指定版本"><a href="#2-4-2-回退到指定版本" class="headerlink" title="2.4.2 回退到指定版本"></a>2.4.2 回退到指定版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">git logs</span><br><span class="line"><span class="comment"># 回退版本：f42aa0e换成需要的版本号</span></span><br><span class="line">git reset --hard f42aa0e</span><br></pre></td></tr></table></figure>



<h3 id="3-管理分支开发"><a href="#3-管理分支开发" class="headerlink" title="3. 管理分支开发"></a>3. 管理分支开发</h3><h4 id="3-1-从其他分支更新本地代码"><a href="#3-1-从其他分支更新本地代码" class="headerlink" title="3.1 从其他分支更新本地代码"></a>3.1 从其他分支更新本地代码</h4><p>假设多人开发，我在dev01，另一个成员在dev02，dev02更新后上传到origin dev02，我需要在本地更新dev02的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin dev02:dev01</span><br></pre></td></tr></table></figure>



<p>看一张图了解原理：</p>
<img src="pull%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">

<p><strong>所以：git pull &#x3D; git fetch + git merge</strong></p>
<h4 id="3-2-绑定远程分支和本地分支"><a href="#3-2-绑定远程分支和本地分支" class="headerlink" title="3.2 绑定远程分支和本地分支"></a>3.2 绑定远程分支和本地分支</h4><p>按照3.1的场景，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev02 origin/dev02 </span><br></pre></td></tr></table></figure>

<p>这个命令做了如下事情：</p>
<ol>
<li><strong>创建本地分支</strong>：如果本地不存在名为 dev02 的分支，这个命令会创建一个新的本地分支 dev02。</li>
<li><strong>设置上游分支</strong>：新创建的本地 dev02 分支会自动设置为跟踪（tracking）远程仓库 origin 上的 dev02 分支。这意味着当你以后在这个本地分支上执行 git pull 或 git  push（不带参数）时，Git 会知道要与远程的 origin&#x2F;dev02 分支进行交互。</li>
</ol>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库：（一）索引底层原理与实现</title>
    <url>/2024/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="一、-什么是索引？"><a href="#一、-什么是索引？" class="headerlink" title="一、 什么是索引？"></a>一、 什么是索引？</h2><p>索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，可以大大加快查询的速度，使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。索引的作用类似于书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<h3 id="1-1-索引概述（了解）"><a href="#1-1-索引概述（了解）" class="headerlink" title="1.1 索引概述（了解）"></a>1.1 索引概述（了解）</h3><p>当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当作一个整体来访问的，这样可以保证操作的原子性。硬盘数据块存储结构类似于链表，都包含数据部分，以及一个指向下一个节点（或数据块）的指针，不需要连续存储。</p>
<p>记录集只能在某个关键字段上进行排序，所以如果需要在一个无序字段上进行搜索，就要执行一个线性搜索（Linear Search）的过程，平均需要访问 N&#x2F;2 的数据块，N 是表示所占据的数据块数目。如果这个字段是一个非主键字段（也就是说，不包含唯一的访问入口）， 那么需要在 N 个数据块上搜索整个表格空间。</p>
<p>但是对于一个有序字段，可以运用二分查找（BinarySearch），这样只需要访问 log2(N)的数据块。这就是为什么数据表使用索引后性能可以得到本质上提高的原因。</p>
<p>索引是对记录集的多个字段进行排序的方法。在一张表中为一个字段创建一个索引，将创建另外一个数据结构，包含字段数值以及指向相关记录的指针，然后对这个索引结构进行排序，允许在该数据上进行二分法排序。索引需要额外的磁盘空间。</p>
<p>对于 MyISAM 引擎而言，这些索引是被统一保存在一张表中的。如果很多字段都建立了索引，那么会占用大量的磁盘空间，这个文件将很快到达底层文件系统所能够支持的大小限制。</p>
<h4 id="1-1-1-索引的作用"><a href="#1-1-1-索引的作用" class="headerlink" title="1.1.1 索引的作用"></a>1.1.1 索引的作用</h4><p>索引除了快没有其他的作用，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。</p>
<h4 id="1-1-2-索引的查找过程"><a href="#1-1-2-索引的查找过程" class="headerlink" title="1.1.2 索引的查找过程"></a>1.1.2 索引的查找过程</h4><p>举一个例子，三个表t1、t2、t3，每个表中只有一个字段，但是每一个表中都有1000行记录，这些记录都是1~1000的数字。</p>
<p>执行以下的查找语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3;</span><br></pre></td></tr></table></figure>


<p>在无索引的情况下处理此查询， 必须寻找 3 个表所有的组合，以便得出与 WHERE 子句相配的那些行。而可能的组合数目 为 1000×1000×1000（十亿）</p>
<p>如果对每个表进行索引，就能极大地加速查询进程，利用索引的查询处理如下。</p>
<p>从表 t1 中选择第一行，查看此行所包含的数据。<br>使用表 t2 上的索引，直接定位 t2 中与 t1 的值匹配的行。同理，利用表 t3 上的索引， 直接定位 t3 中与 t1 的值匹配的行。<br>扫描表 t1 的下一行并重复前面的过程，直到遍历 t1 中所有的行。<br>在这样的情况下，对表 t1 执行了一个完全扫描，但能够在表 t2 和 t3 上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。<br>利用索引，MySQL 加速了 WHERE 子句满足条件行的搜索，而在多表连接查询时、在执行连接时加快了与其他表中的行匹配的速度。</p>
<h2 id="二、索引的分类（逻辑分类）"><a href="#二、索引的分类（逻辑分类）" class="headerlink" title="二、索引的分类（逻辑分类）"></a>二、索引的分类（逻辑分类）</h2><p>逻辑的角度来划分，索引分为普通索引、唯一索引、主键索引、组合索引和全文索引。</p>
<h3 id="2-1-普通索引"><a href="#2-1-普通索引" class="headerlink" title="2.1 普通索引"></a>2.1 普通索引</h3><h4 id="2-1-1-普通索引格式"><a href="#2-1-1-普通索引格式" class="headerlink" title="2.1.1 普通索引格式"></a>2.1.1 普通索引格式</h4><p>普通索引是最基本的索引，它没有任何限制，也是大多数情况下用到的索引。</p>
<p>直接创建索引的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># column 是指定要创建索引的列名</span></span><br><span class="line"><span class="comment"># length 是可选项</span></span><br><span class="line">mysql&gt;CREATE INDEX index_name ON table_name (column(length));</span><br></pre></td></tr></table></figure>

<p>索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字 节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。</p>
<h4 id="2-1-2-创建普通索引"><a href="#2-1-2-创建普通索引" class="headerlink" title="2.1.2 创建普通索引"></a>2.1.2 创建普通索引</h4><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);  <span class="comment">##创建一个表结构</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   |     | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create index id_index on info(<span class="built_in">id</span>);    <span class="comment">##为info表中的id创建索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到在key下面的MUL，索引创建成功了</span></span><br></pre></td></tr></table></figure>




<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">修改表结构的方式添加索引</span><br><span class="line">mysql&gt;ALTER TABLE table_name ADD INDEX index_name (column(length));</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info add index name_index (name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>方法三：<br>在创建一个表结构时，就创建索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table num (<span class="built_in">id</span> int(3),index id_index(<span class="built_in">id</span>));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; describe num;</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| Field | Type   | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>    | int(3) | YES  | MUL | NULL    |       |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<h4 id="2-1-3-查看索引"><a href="#2-1-3-查看索引" class="headerlink" title="2.1.3 查看索引"></a>2.1.3 查看索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from info\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: id_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: name_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h3 id="2-2-唯一索引"><a href="#2-2-唯一索引" class="headerlink" title="2.2 唯一索引"></a>2.2 唯一索引</h3><p>唯一索引与普通索引类似，不同的就是：唯一索引的索引列的值必须唯一，但允许有空<br>值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一。唯一索引创建方法和普<br>通索引类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改表结构的时候添加唯一索引：</span></span><br><span class="line">mysql&gt;CREATEUNIQUEINDEXindex_nameON table_name(column(length));</span><br></pre></td></tr></table></figure>

<p>新建一个表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create unique index unique_name on info2(name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>修改表结构的时候添加唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式</span><br><span class="line">mysql&gt;ALTERTABLEtable_nameADD UNIQUEindex_name(column(length));</span><br></pre></td></tr></table></figure>


<p>创建表的时候同时创建唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATETABLE`table`( </span><br><span class="line">...</span><br><span class="line">UNIQUE index Name (title(length)) );</span><br></pre></td></tr></table></figure>

<h3 id="2-3-主键索引"><a href="#2-3-主键索引" class="headerlink" title="2.3 主键索引"></a>2.3 主键索引</h3><p>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</p>
<p>主键索引也就是primary key，在之前的创建表的过程中已经演示过，有两种方式。</p>
<p>第一种：在字段外创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br></pre></td></tr></table></figure>

<p>第二种：在字段内创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null primary key,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-组合索引（最左前缀）"><a href="#2-4-组合索引（最左前缀）" class="headerlink" title="2.4 组合索引（最左前缀）"></a>2.4 组合索引（最左前缀）</h3><p>平时用的 SQL 查询语句一般都有比较多的限制条件，所以为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。在组合索引的创建中，有两种场景，即为单列索引和多列索引。</p>
<p>特点：<br>遵从最左原则，从左往右依次执行；</p>
<h3 id="2-5-全文索引"><a href="#2-5-全文索引" class="headerlink" title="2.5 全文索引"></a>2.5 全文索引</h3><p>对于较大的数据集，将资料输入一个没有 FULLTEXT 索引的表中，然后创建索引，其 速度比把资料输入现有 FULLTEXT 索引的速度更快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间、非常消耗硬盘空间的做法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info2 add fulltext index addr_index(address);    <span class="comment">##创建全文索引</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  | MUL | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; show index from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>




<h2 id="三、-查看及删除索引"><a href="#三、-查看及删除索引" class="headerlink" title="三、 查看及删除索引"></a>三、 查看及删除索引</h2><h3 id="3-1-查看索引"><a href="#3-1-查看索引" class="headerlink" title="3.1 查看索引"></a>3.1 查看索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看索引的两种方法</span><br><span class="line">mysql&gt;show index from tablename;</span><br><span class="line">mysql&gt;show keys from tablename;</span><br></pre></td></tr></table></figure>


<p>以show keys from tablename为例，两种方法用法相同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show keys from info2;</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| info2 |          0 | PRIMARY     |            1 | <span class="built_in">id</span>          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          0 | unique_name |            1 | name        | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          1 | addr_index  |            1 | address     | NULL      |           0 |     NULL | NULL   | YES  | FULLTEXT   |         |               |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>可以使用 mysql&gt; show keys from info2\G;使用显示结果更加直观</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; mysql&gt; show keys from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Table：表的名称。</p>
</li>
<li><p>Non_unique：如果索引不能包括重复词，则为 0；如果可以，则为 1。</p>
</li>
<li><p>Key_name：索引的名称。</p>
</li>
<li><p>Seq_in_index：索引中的列序号，从 1 开始。</p>
</li>
<li><p>Column_name：列名称。</p>
</li>
<li><p>Collation：列以什么方式存储在索引中。在 MySQL 中，有值‘A’（升序）或 NULL（无分类）。</p>
</li>
<li><p>Cardinality：索引中唯一值数目的估计值。通过运行 ANALYZETABLE 或 myisamchk-a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没 有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</p>
</li>
<li><p>Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列 被编入索引，则为 NULL。</p>
</li>
<li><p>Packed：指示关键字如何被压缩。如果没有被压缩，则为 NULL。</p>
</li>
<li><p>Null：如果列含有 NULL，则含有 YES。如果没有，则该列含有 NO。</p>
</li>
<li><p>Index_type：用过的索引方法（BTREE, FULLTEXT,HASH, RTREE）。</p>
</li>
<li><p>Comment：备注。</p>
</li>
</ol>
<h3 id="3-2-删除索引"><a href="#3-2-删除索引" class="headerlink" title="3.2 删除索引"></a>3.2 删除索引</h3><p>索引在创建之后，是会占用一定的磁盘空间的，因此表内如果有不再使用的索引，从数据库性能方面考虑，最好是删除无用索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">删除索引的两种方式</span><br><span class="line">DROP INDEX 索引名 ON 表名; </span><br><span class="line">ALTER TABLE 表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop index addr_index on info2;    <span class="comment">##删除刚刚创建的全文索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show keys from info2\G;   </span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h2 id="四、-索引的底层原理"><a href="#四、-索引的底层原理" class="headerlink" title="四、 索引的底层原理"></a>四、 索引的底层原理</h2><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>Mysql数据库中的常见索引结构有多种，常用Hash，B+树（最常用，多路搜索树）等数据结构来进行数据存储。树的深度加深一层，意味着多一次查询，对于数据库磁盘而言，就是多一次IO操作，导致查询效率低下。</p>
<p><strong>创建一次索引就代表了创建了一个数据结构，例如B+树。</strong></p>
<p><strong>B+树的特征：</strong></p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li>
<li>更适合文件索引系统；</li>
</ol>
<p>此处讨论B+树，结合案例见4.3。</p>
<h3 id="4-2-搜索引擎"><a href="#4-2-搜索引擎" class="headerlink" title="4.2 搜索引擎"></a>4.2 搜索引擎</h3><p>常见的有InnoDB、MyASIM（不支持数据库事务）、Memory等。存储引擎和存储方式（磁盘等）见文章：<a href="https://blog.csdn.net/wangfeijiu/article/details/112454405">MySQL体系构架、存储引擎和索引结构</a></p>
<p>此处使用InnoDB来讨论索引的存储结构，见4.3。</p>
<h3 id="4-3-InnoDB-B-树存储数据结构"><a href="#4-3-InnoDB-B-树存储数据结构" class="headerlink" title="4.3 InnoDB B+树存储数据结构"></a>4.3 InnoDB B+树存储数据结构</h3><p>存储数据结构，也是索引分类的一种：物理分类（第二章讲了逻辑分类）。物理分类分为<strong>聚簇索引</strong>和非聚簇索引。存储数据结构虽然说是索引分类的一种，但是准确的来说，<strong>聚簇索引和非聚簇索引是一种数据的存储方式。</strong></p>
<p><strong>聚簇索引（clustered index）</strong>不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<img src="%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p><strong>非聚簇索引（辅助索引或者二级索引）</strong>：数据和索引是分开的，非聚簇索引的叶子节点并不存储数据表中的完整数据记录。相反，它们存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。</p>
<img src="%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p>虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是只有InnoDB的<strong>主键索引</strong>（主键索引见2.3）才是聚簇索引，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。</p>
<p><strong>使用聚簇索引的优缺点（面试）：</strong></p>
<p>优点：</p>
<ol>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂（页分裂见4.2链接、下图，属于操作系统的知识），严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）</p>
</li>
<li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
</li>
<li><p>二级索引（非聚簇索引）访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
</li>
</ol>
<img src="f6cd40465df212dd91614785713be6cb.gif" style="zoom:150%;">





<h3 id="4-4-回表是什么？为什么会有回表？"><a href="#4-4-回表是什么？为什么会有回表？" class="headerlink" title="4.4 回表是什么？为什么会有回表？"></a>4.4 回表是什么？为什么会有回表？</h3><p>在4.3的聚簇索引中，我们提到缺点的第三条，非聚簇索引需要两次索引查找，这个过程我们就称为回表。</p>
<p>为什么会有回表？我们刚说到，聚簇索引是将索引和数据存储放在一起的，所以找到索引了就是找到了数据。但是根据实际查询的要求，不一定只会根据主键去查询数据。我们看以下场景：</p>
<p>假如有个表T， 里面三个字段：id k name， id为主键，并且其中对k建立了单独索引。此时有两棵B+树，一个是聚簇索引（主键索引）的B+树，一个是非聚簇索引的B+树。</p>
<ol>
<li><p>如果语句是 select * from T where id&#x3D;500，即主键查询方式（聚簇索引），则只需要搜索 ID 这棵 B+ 树，查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k from T where k&#x3D;5，即普通索引查询方式（非聚簇索引），则只要搜索 k 索引树，这样的话查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k , name from T where k&#x3D;5，第一次通过普通索引查询方式得到 id 的值为 500，再到 id 索引树搜索一次（需要回表才能查到name这个数据）。此时这个过程就成为回表了，回表是基于聚簇索引的缺点之一。</p>
</li>
</ol>
<p>所以为了避免回表，那么可以将k和name建成联合索引（<strong>因为在非主键索引就可以查询到数据，也称为覆盖索引）。</strong></p>
<p><strong>为什么建成联合索引就可以避免回表？</strong></p>
<p>在4.3中提到，非聚簇索引的叶子结点存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。那么查询到K或者name后，自然的指向了对应的id，那么这个行数据自然也就拿到了。</p>
<h2 id="五、总结-面试"><a href="#五、总结-面试" class="headerlink" title="五、总结+面试"></a>五、总结+面试</h2><p>本篇文章介绍了索引的类型，底层原理。mysql的语句了解即可，需要时查起来就可以。另外，文章针对面试需要知道的内容，这样背八股文也能很快反应过来不需要记得太难。</p>
<p>面试需要掌握的知识：mysql的搜索引擎和搜索引擎的差别（4.2节）、mysql的底层存储原理（4.1节，B+树等），mysql数据库优化（4.4节，涉及索引优化），另外需要掌握：mysql锁，mysql事务、mysql数据库优化、数据库备份等。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
